// 01:35 START!
// 분할 정복? DP!
class Solution {
    // n = 1일 때, (뚜껑이 있다면) 4가지 경우 / (뚜껑이 없다면) 3가지 경우
    // n = 2일 때, (뚜껑이 있다면) (n = 1) * 3가지 / (뚜껑이 없다면) (n = 1) * 2 
    // ❗️ 둘이 연결되어 있다면? (n=1에 뚜껑이 있으면) +3가지 / (n=1에 뚜껑이 없으면) +2가지
    // n = 3일 때, (뚜껑이 있다면) (n = 2) * 3가지 / (뚜껑이 없다면) (n = 2) * 2가지
    // ❗️ 둘이 연결되어 있다면? (n=2에 뚜껑이 있으면) +3가지 / (n=2에 뚜껑이 없으면) +2가지 => but 이렇게 ❌ n=2와 n=1이 연결된 부분도 고려해야됨!
    // (n=2에 뚜껑이 있으면) 2가지 * (n=1) / (n=2에 뚜껑이 없으면) 1가지 * (n=1)
    // (n=1에 뚜껑이 있으면) 3가지 + (n=1에 뚜껑이 없으면) 2가지
    public int solution(int n, int[] tops) {
        int answer = 0;
        int[][] dp = new int[n+1][2]; // dp[i][0]는 n=i일 때 채울 수 있는 경우의 수, dp[i][1]은 n=i이고, 마지막 아래 삼각형이 없을 때 채울 수 있는 경우의 수
        dp[1][0] = (tops[0] == 1) ? 4 : 3;
        dp[1][1] = (tops[0] == 1) ? 3 : 2;
        
        for(int i = 2; i <= n; ++i) {
            dp[i][0] = ((tops[i-1] == 1) ? 3 * dp[i-1][0] : 2 * dp[i-1][0]) + dp[i-1][1];
            dp[i][1] = ((tops[i-1] == 1) ? 2 * dp[i-1][0] : dp[i-1][0]) + dp[i-1][1];
            dp[i][0] %= 10007;
            dp[i][1] %= 10007;
        }
        
        return dp[n][0];
    }
}